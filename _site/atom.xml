<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-22T22:59:18+09:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">빈둥빈둥 공부블로그</title><author><name>Eunbin Park</name></author><entry><title type="html">행렬방정식 - 특수행렬 with Scipy &amp;amp; 여러 식을 한꺼번에 풀기</title><link href="http://localhost:4000/linear_algebra/2021/01/22/5-%ED%8A%B9%EC%88%98-%ED%96%89%EB%A0%AC/" rel="alternate" type="text/html" title="행렬방정식 - 특수행렬 with Scipy &amp;amp; 여러 식을 한꺼번에 풀기" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/linear_algebra/2021/01/22/5-%ED%8A%B9%EC%88%98-%ED%96%89%EB%A0%AC</id><content type="html" xml:base="http://localhost:4000/linear_algebra/2021/01/22/5-%ED%8A%B9%EC%88%98-%ED%96%89%EB%A0%AC/">&lt;h3 id=&quot;toeplitz-행렬-solver&quot;&gt;Toeplitz 행렬 Solver&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve_toeplitz((c, r), b)&lt;/code&gt; : c/r - 1D array (vector)&lt;br /&gt;
기본 알고리즘 : Levinson-Durbin Recursion 계산량 \(\sim n^2\) 행렬사이즈의 2승에 비례하는 량&lt;br /&gt;
행렬 사이즈가 커질 수록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solve_toeplitz&lt;/code&gt; 함수가 유리함&lt;/p&gt;

&lt;h4 id=&quot;toeplitz-matrix-구축&quot;&gt;Toeplitz Matrix 구축&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.toeplitz(c,r)&lt;/code&gt; 이게 꼭 필요할까? 작은사이즈 외에 경우에는 필요하지 않음&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;circulant-행렬-solver&quot;&gt;Circulant 행렬 Solver&lt;/h3&gt;

&lt;p&gt;0번째 컬럼만 알면 가능&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solver_circulant(c, b)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;기본 알고리즘 : Discrete Fourier Transform → 실질적으로 Fast Fourier transform 으로 문제를 해결&lt;/p&gt;

&lt;p&gt;행렬사이즈 n의 log(n)에 비례하는 계산량 : \(\sim nlog(n)\)&lt;/p&gt;

&lt;h4 id=&quot;circulant-matrix-구축&quot;&gt;Circulant Matrix 구축&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.circulant(c)&lt;/code&gt; : 추천하지 않음&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;여러-식을-한꺼번에-풀기-&quot;&gt;여러 식을 한꺼번에 풀기 !&lt;/h3&gt;

&lt;p&gt;→ b벡터가 여러개일 때 한번에 푸는 방법&lt;br /&gt;
→ A가 불변하고 B는 이미 주어진 상황이라면,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반행렬&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve(A, B, {assume_a = 'gen'})&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve_triangular(A, B, {lower = False})&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;밴드행렬&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve_banded((lbw, ubw),  band_a, B)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solveh_banded(band_a_h, B, lower=False)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;특수행렬&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve_toeplitz((c, r), B)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve_circulant(c, B)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;→ 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; &lt;strong&gt;벡터를 행렬&lt;/strong&gt;로 넣어주면 결과를 반환함&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Linear_Algebra" /><summary type="html">Toeplitz 행렬 Solver</summary></entry><entry><title type="html">행렬방정식 - 일반행렬 with Scipy</title><link href="http://localhost:4000/linear_algebra/2021/01/22/3-%EC%9D%BC%EB%B0%98-%ED%96%89%EB%A0%AC/" rel="alternate" type="text/html" title="행렬방정식 - 일반행렬 with Scipy" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/linear_algebra/2021/01/22/3-%EC%9D%BC%EB%B0%98-%ED%96%89%EB%A0%AC</id><content type="html" xml:base="http://localhost:4000/linear_algebra/2021/01/22/3-%EC%9D%BC%EB%B0%98-%ED%96%89%EB%A0%AC/">&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scipy&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linalg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;determinant-구하기&quot;&gt;Determinant 구하기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.det(A)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;기본 알고리즘 : LU Decomposition&lt;/p&gt;

&lt;p&gt;→ A = LU \(det(A) = det(L * U) = det(L) * det(U) = det(U)\) : U의 대각항들만 모두 곱해주는 형태로 구해짐&lt;/p&gt;

&lt;h4 id=&quot;lapack-함수-subroutine&quot;&gt;Lapack 함수 (subroutine)&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zgetrf&lt;/code&gt; : complex128&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dgetrf&lt;/code&gt; : float64&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;역행렬-구하기&quot;&gt;역행렬 구하기&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;목적이 행렬방정식 Ax=b를 구하는 거라면 사용하지 말자!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.inv(A)&lt;/code&gt; &amp;gt; 역행렬이 없으면 singular matrix 에러 출현! : 수학적으로는 에러가 아니지만, 수치적으로 에러에 기인해 판단될 수도 있음 (구분이 불가함)&lt;/p&gt;

&lt;h4 id=&quot;기본-알고리즘&quot;&gt;기본 알고리즘&lt;/h4&gt;

&lt;p&gt;LU Decomposition : Solve \(LUA^{-1} = I\) : Backward phase (backsubstitution)&lt;/p&gt;

&lt;h4 id=&quot;lapack&quot;&gt;Lapack&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getrf&lt;/code&gt; : LU decomposition&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getri&lt;/code&gt; : inverse from triangular matrix : 트라이앵귤러 매트릭스를 푸는 solver 역할을 겸함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;ax--b-풀기&quot;&gt;Ax = b 풀기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve(A, b, assume_a=&quot;gen&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assume_a&lt;/code&gt; : 입력으로 들어오는 행렬의 특성&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정을 잘못 넣어도 별다른 오류 출력이 없음&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gen : 행렬의 특성을 모를 때 LU decomposition - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gesv&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;sym : (Real or Complex) Symmetric Metrix \(A = A^T\) Diagonal pivoting \(A = LDL^T\) : block diagonal - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysv&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;her : Hermitian matrix \(A = A^*\) Diagonal Pivoting \(A = LDL^*\) - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hesv&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;pos : Positive Definite  \(x^TAx &amp;gt; 0\) Symmetric or Hermitian Cholesky decomposition : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;posv&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;triangular-matrix-solver&quot;&gt;Triangular Matrix Solver&lt;/h3&gt;

&lt;p&gt;Ax = b, A = Upper(lower) triangular matrix&lt;/p&gt;

&lt;p&gt;Backward phase (backsubstitution) 과정만이 필요함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve_triangular(A, b, {lower = False})&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;lapack-1&quot;&gt;Lapack&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trtrs&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;해의-정확성&quot;&gt;해의 정확성&lt;/h3&gt;

&lt;p&gt;Ax = b, x = 수치적 계산으로 근사된 값&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Q1. Ax와 b가 충분히 비슷한가 ?&lt;/li&gt;
  &lt;li&gt;Q2. Ax - b 충분히 작은가? 0에 충분히 가까운가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;엔트리의 오차를 직접 계산할 수 있음 (절대 / 상대 오차 모두)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.allclose(A@x, b)&lt;/code&gt; 변수의 모든 엔트리를 비교해 충분히 비슷하다면 True → &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.allclose(A@x - b, np.zeros((b.shape[0], )))&lt;/code&gt;&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Linear_Algebra" /><summary type="html">from scipy import linalg</summary></entry><entry><title type="html">왜 역행렬을 구하는 것보다 Ax=b를 푸는게 좋을까?</title><link href="http://localhost:4000/linear_algebra/2021/01/22/2-%EC%97%AD%ED%96%89%EB%A0%AC%EB%B3%B4%EB%8B%A4-Ax=b/" rel="alternate" type="text/html" title="왜 역행렬을 구하는 것보다 Ax=b를 푸는게 좋을까?" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/linear_algebra/2021/01/22/2-%EC%97%AD%ED%96%89%EB%A0%AC%EB%B3%B4%EB%8B%A4-Ax=b</id><content type="html" xml:base="http://localhost:4000/linear_algebra/2021/01/22/2-%EC%97%AD%ED%96%89%EB%A0%AC%EB%B3%B4%EB%8B%A4-Ax=b/">&lt;p&gt;\(A^{-1}\) 을 한 번 구해두면 \(x = A^{-1}b\) 를 통해 해를 구하면 되지 않을까?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;\(A^{-1}\)을 구해 해를 찾는 경우
    &lt;ol&gt;
      &lt;li&gt;\(A^{-1}\)을 구하는 노력 \(\backsim n^3\) 행렬사이즈의 3승&lt;/li&gt;
      &lt;li&gt;\(A^{-1}b\)의 계산 노력 \(\backsim n^2\)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;\(Ax = b\)를 풀어 해를 찾는 경우
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Gauss Elimminaton&lt;/strong&gt; \(Ax = b\)를 푸는 노력 \(\backsim n^3\)&lt;/li&gt;
      &lt;li&gt;**LU decomposition ** \(A = LU\) 를 찾는 노력 \(\backsim n^3\) → LUx = b를 푸는 노력 \(\backsim n^2\)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;수치적-정확도--해의-정확도-&quot;&gt;수치적 정확도 ( 해의 정확도 )&lt;/h3&gt;

&lt;p&gt;컴퓨터에서는 제한된 소수점으로 표현&lt;/p&gt;

&lt;h3 id=&quot;희소행렬의-역행렬과-lu-decomposition-비교&quot;&gt;희소행렬의 역행렬과 LU Decomposition 비교&lt;/h3&gt;

&lt;p&gt;행렬 대부분이 0일 경우 ( Sparse Matrix )&lt;/p&gt;

&lt;p&gt;역행렬은 sparse 하지 않음&lt;/p&gt;

&lt;p&gt;L과 U는 여전히 Sparse 한 경우가 많음&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;특별히 \(A^{-1}\)이 필요한 경우가 아니면, \(A\mathbf{x} = b\)를 풀 때 역행렬을 구하지 말자!&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Linear_Algebra" /><summary type="html">\(A^{-1}\) 을 한 번 구해두면 \(x = A^{-1}b\) 를 통해 해를 구하면 되지 않을까?</summary></entry><entry><title type="html">Matrix 분류와 적합한 Inverse 알고리즘</title><link href="http://localhost:4000/linear_algebra/2021/01/22/1-Matrix%EB%B6%84%EB%A5%98%EC%99%80-%EC%A0%81%ED%95%A9%ED%95%9C-Inverse-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="Matrix 분류와 적합한 Inverse 알고리즘" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/linear_algebra/2021/01/22/1-Matrix%EB%B6%84%EB%A5%98%EC%99%80-%EC%A0%81%ED%95%A9%ED%95%9C-Inverse-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="http://localhost:4000/linear_algebra/2021/01/22/1-Matrix%EB%B6%84%EB%A5%98%EC%99%80-%EC%A0%81%ED%95%A9%ED%95%9C-Inverse-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">&lt;h2 id=&quot;성질로써의-분류&quot;&gt;성질로써의 분류&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Real Matrix
    &lt;ol&gt;
      &lt;li&gt;Symmetric
        &lt;ol&gt;
          &lt;li&gt;Positive definite&lt;/li&gt;
          &lt;li&gt;Negative definite&lt;/li&gt;
          &lt;li&gt;Indefinite&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;Non-Symmetric&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Complex Matrix&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;Hermitian A = A* 에르미트&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;Real symmetric 의 성질들이 에르미트에도 적용될 수 있음&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Positive definite : \(\mathbf{x}^*A\mathbf{x} &amp;gt; 0\)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Non-Hermitian&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;positive-definite-일-경우&quot;&gt;Positive Definite 일 경우&lt;/h3&gt;

&lt;h4 id=&quot;cholesky-decomposition&quot;&gt;Cholesky decomposition&lt;/h4&gt;

&lt;p&gt;R(L) =&amp;gt; Upper(Lower) triangular matrix&lt;/p&gt;

&lt;p&gt;Real Matrix Positive definite → \(A = R^T R = LL^T\)&lt;/p&gt;

&lt;p&gt;Complex Matrix Positive definite → \(A = R^* R = LL^*\)&lt;/p&gt;

&lt;h4 id=&quot;ldl-decomposition&quot;&gt;LDL decomposition&lt;/h4&gt;

&lt;p&gt;Tridiagonal 형태에서 적용함 ( 간단한 형태 )&lt;/p&gt;

&lt;p&gt;D =&amp;gt; Diagonal Matrix&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
\[A = UDU^T = LDL^T\]
  &lt;/li&gt;
  &lt;li&gt;
\[A = UDU^* = LDL^*\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;indefinite&quot;&gt;Indefinite&lt;/h3&gt;

&lt;h4 id=&quot;diagonal-pivoting-method&quot;&gt;Diagonal Pivoting method&lt;/h4&gt;

&lt;p&gt;D =&amp;gt; Block Diagonal Matrix 블럭은 &lt;strong&gt;최대 2 by 2&lt;/strong&gt; 형태&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Block symmetric diangonal : \(A = UDU^T = LDL^T\)&lt;/li&gt;
  &lt;li&gt;Block Hermitian diangonal : \(A = UDU^* = LDL^*\)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;complex-symmetric-matrix&quot;&gt;Complex symmetric matrix&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;반드시 에르메트 형태와 구분지어야 함!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주로 나오는 분야 : Boundary integral equations&lt;/p&gt;

&lt;p&gt;**Non-Hermitian Matrix ** Definiteness ? → posi, nega, indef 가 모호해짐 : 일반적으로 정의가 되어있지 않음.&lt;/p&gt;

&lt;p&gt;보통 Diagonal Pivoting method 알고리즘을 사용!&lt;/p&gt;

&lt;p&gt;\(A = UDU^T = LDL^T\) 형태의 Decomposition을 사용 : Real symmetric matrix 처럼 풀면 된다.&lt;/p&gt;

&lt;h2 id=&quot;모양으로써의-분류&quot;&gt;모양으로써의 분류&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Full Matrix&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Band Matrix : Band의 일부만 존재하고 나머지는 0으로 채워진 경우 ( Diagonal 부분 제외)&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;컴퓨터 언어마다 row/col 접근 방식 속도 차이가 나기 때문에 저장 방식을 고려해야 함&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Digital Image Processing, Signal Processing, Cryptography 등의 분야에서 나오는 특수한 Matrix&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Toepliz matrix : 태각선 항의 값이 모두 동일함, 마이너스 인덱스로 표현&lt;/p&gt;

    &lt;p&gt;→ Levinson-Durbin recursion \(~n^2\) &amp;gt; 필요 저장 공간은 컬럼 하나 : 정확도 문제 존재&lt;/p&gt;

    &lt;p&gt;→ Bareiss algorithm \(~n^2\) &amp;gt; 풀매트릭스를 저장하는 단점이 있음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Circulant Matrix : 열의 값이 순환함&lt;/p&gt;

    &lt;p&gt;→ Circular convolution theorem&lt;/p&gt;

    &lt;p&gt;→ Discrete Fourier transform&lt;/p&gt;

    &lt;p&gt;→ Fast Fourier transform \(~nlog(n)\)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Eunbin Park</name></author><category term="Linear_Algebra" /><summary type="html">성질로써의 분류</summary></entry><entry><title type="html">행렬방정식 - 밴드행렬 with Scipy</title><link href="http://localhost:4000/linear_algebra/2021/01/22/4-%EB%B0%B4%EB%93%9C-%ED%96%89%EB%A0%AC/" rel="alternate" type="text/html" title="행렬방정식 - 밴드행렬 with Scipy" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/linear_algebra/2021/01/22/4-%EB%B0%B4%EB%93%9C-%ED%96%89%EB%A0%AC</id><content type="html" xml:base="http://localhost:4000/linear_algebra/2021/01/22/4-%EB%B0%B4%EB%93%9C-%ED%96%89%EB%A0%AC/">&lt;h3 id=&quot;scipy에서의-밴드행렬-입력&quot;&gt;Scipy에서의 밴드행렬 입력&lt;/h3&gt;

&lt;p&gt;bandwidth » n (행렬사이즈) 일 때 유용함&lt;br /&gt;
column index를 유지하면서 밴드만 가져와 가로 형태로 쌓아줌&lt;/p&gt;

&lt;h3 id=&quot;밴드행렬-solver&quot;&gt;밴드행렬 Solver&lt;/h3&gt;

&lt;p&gt;\(A\mathbf{x} = b\) 일 때, A는 밴드행렬이 유리&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linalg.solve_banded((lbw 폭, ubw 폭), band_a, b)&lt;/code&gt; &lt;br /&gt;
기본 알고리즘&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LU Decomposition : - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gbsv&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Tridiagonal Solver : lbw, ubw = 1 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gtsv&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;밴드행렬-solver의-solution-확인&quot;&gt;밴드행렬 Solver의 Solution 확인&lt;/h4&gt;

&lt;p&gt;Band_A @ x != b → A @ x = b &lt;br /&gt;
밴드행렬을 다시 원행렬로 돌리고 Matrix-vector multiplication 은 본래의 목적에서 벗어남 (메모리)&lt;/p&gt;

&lt;p&gt;TBC&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Linear_Algebra" /><summary type="html">Scipy에서의 밴드행렬 입력</summary></entry><entry><title type="html">Numpy 편의기능 및 기본조작 1 ~ 3</title><link href="http://localhost:4000/linear_algebra/2021/01/20/numpy-%ED%8E%B8%EC%9D%98-%EA%B8%B0%EB%8A%A5/" rel="alternate" type="text/html" title="Numpy 편의기능 및 기본조작 1 ~ 3" /><published>2021-01-20T00:00:00+09:00</published><updated>2021-01-20T00:00:00+09:00</updated><id>http://localhost:4000/linear_algebra/2021/01/20/numpy-%ED%8E%B8%EC%9D%98-%EA%B8%B0%EB%8A%A5</id><content type="html" xml:base="http://localhost:4000/linear_algebra/2021/01/20/numpy-%ED%8E%B8%EC%9D%98-%EA%B8%B0%EB%8A%A5/">&lt;p&gt;Numpy 편의기능 및 기본조작&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.eye(row, {col}, {band_id}, {dtype})&lt;/code&gt; : band에 1 채워넣기&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0,0 을 기준으로 대각선 항 -&amp;gt; band&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../images/numpy-basic.png&quot; alt=&quot;numpy-basic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.identity(num, {dtype})&lt;/code&gt; : identity matrix&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Same as  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.eye(3)&lt;/code&gt; : 3x3 매트릭스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.tri(row, {col}, {k=band_id}, {dtype})&lt;/code&gt; : lower triangular matrix&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;nonzero entry = 1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = np.eye(row, {col},{band_id}, {dtype})&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;K &amp;lt;= band id 의 모든 밴드에 1을 채워넣고 나머지는 0 을 채움&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.tril(a, {k=band_id})&lt;/code&gt; : band_id를 포함한 lower 부분을 copy&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.triu(a, {k=band_id})&lt;/code&gt; : band_id를 포함한 upper 부분을 copy&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.full((row, col), value)&lt;/code&gt; : 지정된 값으로 채우기&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.randomn.rand(row, col)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터타입 지정 불가 -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.float64&lt;/code&gt; 고정&lt;/li&gt;
  &lt;li&gt;0과 1 사이 무작위 값으로 채워짐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.copy(a)&lt;/code&gt; : 서로 같은 메모리를 참조 : 하나가 변하면 다른 하나도 변함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.reshape(a, vector or shape)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.reshape(a, 6)&lt;/code&gt; : 1D array&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.reshape(a, (3, 2))&lt;/code&gt; : 2D array&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.diag(a, k=band_id)&lt;/code&gt; : band 추출 후 1D array로 만듦&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;b is READ ONLY&lt;/li&gt;
  &lt;li&gt;동일 메모리 공간 참조&lt;/li&gt;
  &lt;li&gt;입력이 1D array (벡터)이면 square 행렬 생성&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;../../images/np-diag-1.png&quot; alt=&quot;np-diag-1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;/Users/eunbinpark/workspace/42cosmos.github.io/images/np-diag-2.png&quot; alt=&quot;np-diag-1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.diagflat(M, k=band_id)&lt;/code&gt; : M를 1D화 한뒤에 square matrix 생성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;../../images/np.diagflat-1.png&quot; alt=&quot;np.diagflat-1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.trace(a, offset=band_id)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;diagonal entry ( band entry )를 더한 값&lt;/li&gt;
  &lt;li&gt;\(\left[\begin{matrix}\\1 &amp;amp; 2 &amp;amp; 3 \\1 &amp;amp; 2 &amp;amp; 3 \\1 &amp;amp; 2 &amp;amp; 3 \\ \end{matrix}\right]\)  →  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.trace(a)&lt;/code&gt; returns 15, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.trace(a, offset=-1)&lt;/code&gt; returns 12&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.hstack((tuple))&lt;/code&gt; : 수평으로 쌓아감 - tuple 순서대로 행(row, shape[0]) 개수가 맞아야 함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.vstack((tuple))&lt;/code&gt; : 수직으로 쌓아감 - tuple 순서대로 행(col, shape[0]) 개수가 맞아야 함&lt;/p&gt;

&lt;h3 id=&quot;methods&quot;&gt;Methods&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transpose()&lt;/code&gt; method&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단, 1d arr는 무변&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatten&lt;/code&gt; method&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;행렬 a를 1d  array 로 만들어 copy&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.ravel(a)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;properties&quot;&gt;Properties&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real&lt;/code&gt; : 실수 부분&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imag&lt;/code&gt; : 허수 부분&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;conjegate&lt;/code&gt;: copy&lt;/p&gt;

&lt;h3 id=&quot;matrix-multiplication&quot;&gt;Matrix Multiplication&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1 @ M2&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.matmul(M1, M2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;*** or / is not multiplication !! **&lt;/p&gt;

&lt;h3 id=&quot;matrix-vector-product&quot;&gt;Matrix-Vector Product&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M @ arr&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.matmul(M, arr)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;inner-product&quot;&gt;Inner Product&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.dot()&lt;/code&gt; is …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Real vector same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vdot()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;complex vector : conjugate가 빠진 채로 계산&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Eunbin Park</name></author><category term="Linear_Algebra" /><summary type="html">Numpy 편의기능 및 기본조작</summary></entry><entry><title type="html">프로그래머스 - 기능개발</title><link href="http://localhost:4000/algorithm/2021/01/18/programmars-42586/" rel="alternate" type="text/html" title="프로그래머스 - 기능개발" /><published>2021-01-18T00:00:00+09:00</published><updated>2021-01-18T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2021/01/18/programmars-42586</id><content type="html" xml:base="http://localhost:4000/algorithm/2021/01/18/programmars-42586/">&lt;h3 id=&quot;오늘의-문제&quot;&gt;오늘의 문제&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42586&quot;&gt;프로그래머스 기능개발&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;동일한 크기의 두 개의 리스트를 계산한다. 앞보다 뒤 값이 작으면 카운트 해준다.&lt;/p&gt;

&lt;h3 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;progresses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;93&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;speeds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# return [2, 1]
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;temp_result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sp&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;progresses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;speeds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# return [7, 3, 9]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;0번째 인덱스 93퍼센트 진행률의 하루 1퍼센트의 속도를 보인다. 7일 후 프로세스가 완료된다.&lt;/p&gt;

&lt;p&gt;이런 식이다. 완료시점(100퍼센트)까지 계산은 쉽다. 남은 진척도를 구하고 스피드를 나눠준 후 , 소숫점은 무조건 올려주면 된다.&lt;/p&gt;

&lt;p&gt;여기까진 쏘이지~&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;retval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;retval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;temp_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;retval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;i-1 번째가 i번째보다 크면 결과 리스트에 삽입하고 1로 초기화 해준다.&lt;/p&gt;

&lt;p&gt;i-1 번째가 i번째보다 작으면,  i-1번째는 그 넘어의 숫자와 비교되어야하기 때문에, i 번째에 넣어주고 answer( count )를 하나 올려주고 for문을 지속한다.&lt;/p&gt;

&lt;h3 id=&quot;사담&quot;&gt;사담&lt;/h3&gt;

&lt;p&gt;진짜 아쉬웠다… 다 풀었는데… 내가 24시간을 꼬박 샜고… 두통이 엄청 와서 못 푼 거다… 그런거다 ^^&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Algorithm" /><summary type="html">오늘의 문제 프로그래머스 기능개발</summary></entry><entry><title type="html">프로그래머스 - 멀쩡한 사각형</title><link href="http://localhost:4000/algorithm/2021/01/14/programmars-62048/" rel="alternate" type="text/html" title="프로그래머스 - 멀쩡한 사각형" /><published>2021-01-14T00:00:00+09:00</published><updated>2021-01-14T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2021/01/14/programmars-62048</id><content type="html" xml:base="http://localhost:4000/algorithm/2021/01/14/programmars-62048/">&lt;h3 id=&quot;오늘의-문제&quot;&gt;오늘의 문제&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/62048#qna&quot;&gt;프로그래머스 멀쩡한 사각형&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;문제 간략 설명 : 12 by 8 배열의 사각형에서 대각선의 불능을 제외 후 개수를 세어 반환하는 문제&lt;/p&gt;

&lt;h3 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/programmars_62048.png&quot; alt=&quot;&quot; /&gt;&lt;!-- {&quot;width&quot;:379} --&gt;&lt;/p&gt;

&lt;p&gt;문제의 답을 직관적으로 알 수 있다. 가로 2씩 세로 3씩 증가하고, 3 by 2의 도형 안에서 불능 도형의 개수를 찾고, 이 패턴이 몇 번 반복되는지 알아내면 된다 !&lt;/p&gt;

&lt;p&gt;8 → 2, 12 → 3 니까 4 ! → 4번 패턴이 반복되는 건 두 수 사이의 최대공약수를 찾아주면 된다.&lt;/p&gt;

&lt;p&gt;3 by 2 은 6개 중 4개가 불능, 12 by 8 은 96개 중 16개가 불능이다.&lt;/p&gt;

&lt;p&gt;주어진 가로와 세로에 최대공약수를 나누어주고 -1을 한다. 그러고 반복되는 패턴이 4번 (12와 8의 최대공약수)이니 이만큼 곱해준다! …최대공약수 함수는 구글링해서 주웠다. ㅎㅎ 근데 math 모듈에 있더라고? 암튼&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;((w / gcd(w, h) + h / gcd(w, h)) - 1 ) * gcd(w, h)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러고 전체 도형에서 불능 도형의 개수를 빼주면 끝~&lt;/p&gt;

&lt;h3 id=&quot;사담&quot;&gt;사담&lt;/h3&gt;

&lt;p&gt;개인적으로 직관적인 문제는 무식하게 풀 수 있다고 생각하기에… 빈 종이에 손으로 쓰면서 문제를 풀었다.&lt;/p&gt;

&lt;p&gt;대각선이 지나갈 때의 불능 도형의 개수가 제일 머리 아팠다… 뭐랄까 애기 때 수학 공부를 잘했으면 금방 풀었을텐데 하는 생각이 들 정도로 간단해보이는데 잘 모르겠고… 이게 맞는데 왜 그런지는 모르겠는 그런 너낌&lt;/p&gt;

&lt;p&gt;직관적인 문제 → 무식하게 풀기 가 아니라 그냥 무식한 나도 풀 수 있다는 걸 알게됐다…🥲&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Algorithm" /><summary type="html">오늘의 문제 프로그래머스 멀쩡한 사각형</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/images/programmars_62048.png" /><media:content medium="image" url="http://localhost:4000/images/programmars_62048.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">프로그래머스 크롤링</title><link href="http://localhost:4000/algorithm/2021/01/12/programmars-crawling/" rel="alternate" type="text/html" title="프로그래머스 크롤링" /><published>2021-01-12T00:00:00+09:00</published><updated>2021-01-12T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2021/01/12/programmars-crawling</id><content type="html" xml:base="http://localhost:4000/algorithm/2021/01/12/programmars-crawling/">&lt;p&gt;21년 1월부터 연구실에선 매일 오전 9시 30분부터 한 시간동안 파이썬 알고리즘 문제를 푼다.&lt;/p&gt;

&lt;p&gt;교수님께서 한 사람씩 돌아가면서 문제를 가져오라고 지정하셨고, 한 사이클이 지나고부터는 오늘은 누군지 겁나게~ 헷갈리기 시작했고, 누가 스프린트를 빠진다고 하면 그때부터 불안했다. 나만 기억 못하나 싶을 정도로 무덤덤한 사람들 … ㅎ 어떤 날은 서로 자기인 줄 알았다며 문제를 두 명이 들고온 적도 있었는데. 
이게 내 성격이긴 한데…   정리되지 않은 상태…  나쁘게 말하면 아노미 상태ㅋㅋㅋㅋ가 싫다. 시간을 조금만 투자하면 잘 정돈된 상태를 만들 수 있는데… 그 상황에 내가 포함되어 있다면 발벗고 나서야지 뭐… 목마른 사람이 우물 파니까&lt;/p&gt;

&lt;p&gt;그냥 크롤링 코드를 짰다. 프로그래머스 사이트가 SPA 인지 뭔지 아무튼 url로 반응하는게 아니었고, 모든 문제가 모든 언어로 풀 수 있는 건 아니었다. 특정 레벨의 특정 언어를 가져와야 했기 때문에 더럽게 귀찮아보였지만… 그래도 손가락을 뽑았으면 코드 한 줄이라도 썰어야 대장부니까 ^^&lt;/p&gt;

&lt;p&gt;뷰티풀솝 익숙해지려고 이걸로 이것저것 하려다 시간만 왕창 잡아먹고 결국 셀레니움으로 …했다.&lt;/p&gt;

&lt;p&gt;여기에 파일 첨부는 어떻게 하는 걸까…?&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Algorithm" /><category term="Algorithm" /><category term="Crawling" /><summary type="html">21년 1월부터 연구실에선 매일 오전 9시 30분부터 한 시간동안 파이썬 알고리즘 문제를 푼다.</summary></entry><entry><title type="html">THEOREMs</title><link href="http://localhost:4000/linear_algebra/2021/01/12/ch19-Theorems/" rel="alternate" type="text/html" title="THEOREMs" /><published>2021-01-12T00:00:00+09:00</published><updated>2021-01-12T00:00:00+09:00</updated><id>http://localhost:4000/linear_algebra/2021/01/12/ch19-Theorems</id><content type="html" xml:base="http://localhost:4000/linear_algebra/2021/01/12/ch19-Theorems/">&lt;h2 id=&quot;-theorem-1&quot;&gt;📖 Theorem 1.&lt;/h2&gt;
&lt;p&gt;Uniqueness of the Reduced Echelon Form
Each matrix is row equivalent to one and only one reduced echelon matrix&lt;/p&gt;

&lt;h2 id=&quot;-theorem-2&quot;&gt;📖 Theorem 2.&lt;/h2&gt;

&lt;h2 id=&quot;-theorem-3&quot;&gt;📖 Theorem 3.&lt;/h2&gt;
&lt;p&gt;\(A\) is \(m \times n\) matrix, with columns \(a_1, \cdots, a_n   \mathbf{b} \mbox{ is in }\mathbb{R}^m\)&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Matrix Equation : \(A\mathbf{x} = \mathbf{b}\)&lt;/li&gt;
  &lt;li&gt;Vector Equation : \(x_1\mathbf{a_1} + x_2\mathbf{a_2} + \cdots + x_p\mathbf{a_p} = \mathbb{b}\)&lt;/li&gt;
  &lt;li&gt;Augmented Matrix  : \(\left[ \mathbf{a_1}, \mathbf{a_2}, \cdots, \mathbf{a_n} \mathbf{b}\right]\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Have the same solution set!&lt;/p&gt;

&lt;h2 id=&quot;-theorem-4&quot;&gt;📖 Theorem 4.&lt;/h2&gt;
&lt;p&gt;The followings are all true of all false:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;For each b in R^m, Ax = b  has a solution&lt;/li&gt;
  &lt;li&gt;Each b in R^m is a linear combination of the columns of A&lt;/li&gt;
  &lt;li&gt;The columns of A spanR^m&lt;/li&gt;
  &lt;li&gt;A has a pivot position in every row&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;-theorem-5&quot;&gt;📖 Theorem 5.&lt;/h2&gt;
&lt;p&gt;If A is an m x n matrix, u and v are vectors in R^m,  And c is a scalar, then;  &lt;br /&gt;
A(u + v) = Au + Av;&lt;br /&gt;
A(cu) = c(Au)&lt;/p&gt;</content><author><name>Eunbin Park</name></author><category term="Linear_Algebra" /><summary type="html">📖 Theorem 1. Uniqueness of the Reduced Echelon Form Each matrix is row equivalent to one and only one reduced echelon matrix</summary></entry></feed>